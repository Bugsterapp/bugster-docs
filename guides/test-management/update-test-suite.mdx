---
title: "How to update your tests"
description: "Sync your suite with product changes by creating, modifying, and removing tests via `bugster update`."
icon: "wand-magic-sparkles"
"og:type": "article"
"og:title": "Bugster Test Updates - Sync Tests with Code Changes"
"og:description": "Automatically update Bugster test suites from git changes. PR automation, incremental updates, and comparison baselines for evolving codebases."
"og:url": "https://docs.bugster.dev/guides/test-management/update-test-suite"
---

Run `bugster update` to automatically create tests for new functionality, modify tests impacted by code changes, and delete tests for removed features. Use it locally on demand or automatically on every pull request via the GitHub App.

In this guide you will learn:
- How to keep your test suite synchronized with your codebase using `bugster update`.
- How to use different update modes for local development and CI workflows.
- How to compare changes against different baselines like the default branch or the last update.

<Card title="Prerequisites">
- Bugster CLI installed and authenticated.
- Run commands from your repo root (the directory containing `/.bugster/`).
- For PR automation: the Bugster GitHub App is installed on the repo (document required permissions) and PR previews are available if your flow depends on them.
</Card>

## Usage Modes

### Local (manual)

Run `bugster update` when you're confident about local changes and ready to sync them. The command analyzes **committed changes only** - both staged and unstaged files are ignored. Only differences between commits are considered for test updates.

<CodeGroup>
```bash Full update
# Full update (create/modify/delete as needed)
bugster update
```
```bash Scope behavior
# Only modify existing tests
bugster update --update-only

# Only create new tests
bugster update --suggest-only

# Only remove obsolete tests
bugster update --delete-only
```
</CodeGroup>

<Info>
**Scope flag precedence:** If multiple scope flags are provided, the command will error and ask you to specify only one scope option.
</Info>

### Automatic on Pull Requests

When you open a Pull Request, Bugster's E2E agent runs `bugster update` first. New commits or force-pushes will **amend the existing Update PR** rather than creating a new one.

<Steps>
<Step title="Bugster creates an Update PR">
Bugster opens a secondary PR targeting your feature branch with the suggested test suite changes.
</Step>
<Step title="Review the results">
The original PR gets a comment with the test results and a link to the "Bugster Update PR".
</Step>
<Step title="Approve and merge">
You approve and merge the "Bugster Update PR".
</Step>
<Step title="Merge your feature">
Once the test updates are in, you can merge your feature branch.
</Step>
</Steps>

<Warning>
Remember to review the Bugster Update PR **before** merging your feature.
</Warning>

Here is a summary of the flow:
```text
You create a PR  →  bugster update runs  →  Bugster opens "Update PR" → 
Bugster comments results in original PR → you review/merge Update PR → merge feature PR
```

## Comparison Baselines

Choose the comparison model that fits your development stage:

| Baseline | Use When | Command |
| :--- | :--- | :--- |
| Last commit (default) | Small, isolated edits | `bugster update` |
| Default branch | Before PR / comprehensive sweep | `bugster update --against-default` |
| Since last update | Tight inner loop without reprocessing | `bugster update --against-last-update` |

### Last commit (default)
*When to use: Small, isolated edits*

```bash
bugster update
```
**Scope:** Compares your latest commit against the previous commit. Only sees files changed in your most recent commit.

### Against default branch  
*When to use: Before PR / comprehensive sweep*

```bash
bugster update --against-default
```
**Scope:** Compares your current branch against the merge-base with the default branch (e.g., `main`). Sees all changes in your feature branch.

### Since last update
*When to use: Tight inner loop without reprocessing*

```bash
bugster update --against-last-update
```
**Scope:** Compares changes since the last time you ran `bugster update`. The "last update" state is stored in `.bugster/state/last-update-hash` and tracks the commit hash from your previous update.

## Recommended Workflow

| Scenario | Command | Use Case |
| :--- | :--- | :--- |
| During active development | `bugster update --against-last-update` | Tight feedback loop |
| Before opening a PR | `bugster update --against-default` | Final, comprehensive sweep |
| For small, isolated edits | `bugster update` | Default mode usually sufficient |

## Examples

Here are common scenarios and the commands to use.

<AccordionGroup>
<Accordion title="Default update for recently touched files">
```bash
# Create/modify/delete as needed for just-touched files
bugster update
```
</Accordion>
<Accordion title="Full branch comparison before creating a PR">
```bash
# Full branch comparison before PR
bugster update --against-default
```
</Accordion>
<Accordion title="Tight inner loop without reprocessing old changes">
```bash
# Tight inner loop; don't reprocess old changes
bugster update --against-last-update
```
</Accordion>
<Accordion title="Limit to modifications only (no new/deleted tests)">
```bash
# Limit to modifications only (no new/deleted tests)
bugster update --update-only
```
</Accordion>
<Accordion title="Generate suggestions for new areas only">
```bash
# Generate suggestions for new areas only
bugster update --suggest-only
```
</Accordion>
<Accordion title="Purge tests tied to removed features">
```bash
# Purge tests tied to removed features
bugster update --delete-only
```
</Accordion>
<Accordion title="Combine scope and baseline">
```bash
# Combine scope + baseline
bugster update --against-default --update-only
```
</Accordion>
</AccordionGroup>

## Review Tips

<Tip>
- Always review the Update PR diff before merging.
- Keep descriptive commit messages (e.g., `bugster: update tests for billing portal flow`).
- If a change looks incorrect, adjust the code or the test, rerun `bugster update`, and re-review.
</Tip>

That's it: one standardized command keeps your suite aligned with real product changes—locally or automatically on every PR.
